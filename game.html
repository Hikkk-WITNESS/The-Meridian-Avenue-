
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
@import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Share+Tech+Mono&family=JetBrains+Mono:wght@700&display=swap');

/* === åŸºç¡€ç¯å¢ƒé…ç½® === */
html, body {
    background: transparent !important;
    margin: 0 !important;
    padding: 0 !important;
    min-height: 100%;
}

:root {
    --term-bg: #0a0a0a;
    --term-text: #a8a8a8;
    --color-dawn: #d4a017;
    --color-nic: #5a8fb4;
    --color-sehee: #b45a8f;
    --color-laure: #8e7cc3;
    --color-dot: #a07812;
    --color-ui-gold: #c59d5f;
    --color-danger-blood: #a31621; /* è°ƒæš—çº¢è‰²ï¼Œå»é™¤åˆºçœ¼æ„Ÿ */
    --color-warn-gray: #888888;
    --color-obsess-orange: #d68100;
    --color-safe-green: #4caf50;
   --color-hard-red: #a31621;  
}

* {
    touch-action: none !important;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    box-sizing: border-box;
}

body {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    min-height: 100vh;
    overflow: auto;
    font-family: 'Share Tech Mono', monospace;
    padding: 15px 12px !important; 
}

/* === ç»ˆç«¯å®¹å™¨ === */
.zero-terminal {
    background: var(--term-bg);
    border: 2px solid #2a2a2a;
    padding: 6px;
    color: var(--term-text);
    position: relative;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.8), inset 0 0 20px rgba(0,0,0,0.8);
    width: 100%;
    max-width: 400px;
    min-width: 320px; 
    display: flex;
    flex-direction: column;
    border-radius: 6px;
    background-image: url('https://www.transparenttextures.com/patterns/stardust.png');
    margin: 15px 5px !important; 
    flex-shrink: 0; 
}

.zero-terminal::after {
    content: " ";
    display: block;
    position: absolute;
    inset: 0;
    background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
    z-index: 200; 
    background-size: 100% 2px, 3px 100%;
    pointer-events: none; 
}

/* === é¡¶éƒ¨æ  === */
.term-header {
    border-bottom: 1px solid #333;
    padding: 8px 10px;
    margin-bottom: 5px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    letter-spacing: 1px;
    color: #666;
    background: rgba(255,255,255,0.02);
    position: relative;
    z-index: 100;
    height: 32px;
}

.header-left {
    display: flex;
    gap: 8px;
    flex: 1;
    white-space: nowrap;
}

.header-right {
    flex-shrink: 0;
    text-align: right;
    min-width: 100px;
}

/* åœ¨ .status-line ä¹‹å‰æˆ–ä¹‹å¾Œæ·»åŠ é€™æ®µ */
.header-locked {
    opacity: 0.7;
    filter: blur(0.5px);
    pointer-events: none;
}

#diffToggle, #mapToggle {
    cursor: pointer;
    transition: color 0.3s;
}
#diffToggle:hover, #mapToggle:hover {
    color: #fff;
}

/* === æ¸¸æˆç”»å¸ƒåŒºåŸŸ === */
.game-canvas-container {
    position: relative;
    width: 100%;
    aspect-ratio: 1 / 1; 
    background: #050505;
    border: 1px solid #222;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: inset 0 0 10px #000;
}

canvas {
    background: transparent;
    image-rendering: pixelated;
    display: block;
    width: 100%;
    height: 100%;
    z-index: 10;
}

/* === è¦†ç›–å±‚ === */
.overlay {
    position: absolute;
    inset: 0; 
    background: rgba(8, 8, 8, 0.96);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 150; 
    padding: 20px;
    text-align: center;
    border: 1px solid #333;
}

.intro-text { color: #888; font-size: 13px; margin-bottom: 12px; line-height: 1.4; max-width: 90%; }
.term-title-small { color: var(--color-ui-gold); font-size: 16px; margin-bottom: 5px; letter-spacing: 1px; border-bottom: 1px solid rgba(197, 157, 95, 0.3); padding-bottom: 2px; }

.btn-term {
    background: rgba(197, 157, 95, 0.05);
    border: 1px solid var(--color-ui-gold);
    color: var(--color-ui-gold);
    padding: 10px 24px;
    font-family: 'Share Tech Mono';
    font-weight: bold;
    cursor: pointer;
    font-size: 16px;
    text-transform: uppercase;
    box-shadow: 0 0 5px rgba(197, 157, 95, 0.1);
    pointer-events: auto !important;
    margin-top: 5px;
    transition: all 0.2s;
}
.btn-term:active { background: var(--color-ui-gold); color: #000; transform: scale(0.96); }

#hunterLivesUI {
    color: var(--color-danger-blood);
    font-family: 'Share Tech Mono', monospace;
    font-size: 14px;
    margin: 0 8px;
}

#deathMsg, #mercyMsg {
    font-size: 14px; 
    font-weight: normal; 
    margin-bottom: 20px; 
    max-width: 90%; 
    line-height: 1.5;
    /* ç§»é™¤ä¹‹å‰çš„æ–‡å­—é˜´å½±ï¼Œä¿æŒåŸæ¥é¢œè‰² */
    text-shadow: none !important;
    font-style: italic;
    border-left: 2px solid transparent; 
    padding-left: 10px;
    text-align: left;
}

/* =========================
   HUNTER DEATH MESSAGE FIX
========================= */

.hunter-death #deathMsg {
  color: var(--color-danger-blood);
  border-left-color: var(--color-danger-blood);
  text-shadow:
    0 0 6px rgba(163,22,33,0.45),
    0 0 14px rgba(163,22,33,0.25);
}

/* === åº•éƒ¨çŠ¶æ€æ  === */
.status-line {
    padding: 8px 10px;
    font-size: 11px;
    color: #555;
    display: flex;
    justify-content: space-between;
    border-top: 1px solid #222;
    margin-top: 5px;
    height: 30px;
    align-items: center;
}

.score-val { color: var(--color-dawn); font-weight: bold; font-size: 14px; }
.hidden { display: none !important; }

/* ä¿®æ­£åçš„å‘¼å¸åŠ¨ç”»ï¼šæåº¦å¾®å¼± */
@keyframes subtle-flicker { 
    0%, 100% { opacity: 0.98; } 50% { opacity: 1; } 
}
.zero-terminal { animation: subtle-flicker 10s infinite; }

/* =========================
   INFO TOGGLE EFFECT
========================= */

@keyframes infoPulseStrong {
  0%, 100% {
    opacity: 0.6;
    text-shadow: 0 0 6px rgba(197,157,95,0.6);
  }
  50% {
    opacity: 1;
    text-shadow: 0 0 14px rgba(197,157,95,0.9);
  }
}

@keyframes infoPulseSoft {
  0%, 100% { opacity: 0.75; }
  50% { opacity: 1; }
}

.info-pulse-strong {
  color: var(--color-ui-gold);
  animation: infoPulseStrong 1.8s infinite;
}

.info-pulse-soft {
  color: var(--color-ui-gold);
  animation: infoPulseSoft 3.2s infinite;
}

.info-disabled {
  opacity: 0.35;
  pointer-events: none;
  text-shadow: none;
}

/* =========================
   INFO WINDOW OVERLAY
========================= */

.info-overlay {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.55); /* æ“‹ RUN */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 999;
pointer-events: auto;
}

.info-window {
  width: 88%;
  max-width: 360px;
  background: var(--term-bg);
  border: 2px solid #2a2a2a;
  box-shadow:
    0 0 25px rgba(0,0,0,0.8),
    inset 0 0 12px rgba(0,0,0,0.8);
  padding: 14px;
  font-size: 12px;
  color: var(--term-text);
}

/* =========================
   ğŸ–¥ INFO TERMINAL SCANLINES
========================= */

.info-window {
  position: relative;
  overflow: hidden;
}

.info-window {
  position: relative;
  overflow: hidden;
}

/* æ–‡å­— */
.info-title,
.info-content {
  position: relative;
  z-index: 1;
}

/* æŒ‰éˆ•æœ€é«˜ */
#infoCloseBtn {
  position: relative;
  z-index: 5;
}

/* çœŸæ­£çš„æ–‡å­—æƒæç·š */
.info-scanlines {
  position: absolute;
  inset: 0;
  z-index: 2;
  pointer-events: none;

  
  background: repeating-linear-gradient(
    to bottom,
    rgba(0,0,0,0.30) 0px,
    rgba(0,0,0,0.30) 1px,
    transparent 1px,
    transparent 2px
  );


  animation: scanMove 4.5s linear infinite;
}

@keyframes scanMove {
  from { background-position-y: 0; }
  to   { background-position-y: 100%; }
}

.info-content {
  position: relative;
  color: var(--term-text);
line-height: 1.45;

  /* CRT æƒæç·šæ ¸å¿ƒ */
  text-shadow:
    0 1px rgba(255,255,255,0.12),
    0 2px rgba(0,0,0,0.35),
    0 3px rgba(255,255,255,0.06),
    0 4px rgba(0,0,0,0.25);

  animation: crtTextScan 3.5s linear infinite;
}

@keyframes crtTextScan {
  0% {
    text-shadow:
      0 1px rgba(255,255,255,0.10),
      0 2px rgba(0,0,0,0.30),
      0 3px rgba(255,255,255,0.04),
      0 4px rgba(0,0,0,0.20);
  }
  50% {
    text-shadow:
      0 1px rgba(255,255,255,0.16),
      0 2px rgba(0,0,0,0.40),
      0 3px rgba(255,255,255,0.08),
      0 4px rgba(0,0,0,0.30);
  }
  100% {
    text-shadow:
      0 1px rgba(255,255,255,0.10),
      0 2px rgba(0,0,0,0.30),
      0 3px rgba(255,255,255,0.04),
      0 4px rgba(0,0,0,0.20);
  }
}
.info-title {
  color: var(--color-ui-gold);
  font-size: 13px;
  letter-spacing: 1px;
  margin-bottom: 8px;
  border-bottom: 1px solid rgba(197,157,95,0.3);
  padding-bottom: 4px;
z-index: 1;
}

.info-content {
  line-height: 1.6;
  margin-bottom: 12px;
  white-space: pre-line;
z-index: 1;
}


.hidden {
  display: none !important;
}

/* === FIX iOS CLICK FOR INFO WINDOW === */
.info-overlay,
.info-overlay * {
  touch-action: auto !important;
  pointer-events: auto !important;
}

.info-alert {
  animation: infoAlertFlash 0.4s steps(2) 16;
}

@keyframes infoAlertFlash {
  0%   { background: rgba(214,179,106,0.9); color: #000; }
  100% { background: transparent; color: var(--color-info-gold); }
}

/* =========================
   FORCE ENABLE INFO CLOSE CLICK (iOS FIX)
========================= */

#infoCloseBtn {
  pointer-events: auto !important;
  touch-action: manipulation !important;
  -webkit-touch-callout: none;
  position: relative;
  z-index: 9999;
}

/* é—œæ‰æ‰€æœ‰å¯èƒ½æ“‹é»æ“Šçš„å‡å±¤ */
#infoCloseBtn::before,
#infoCloseBtn::after {
  pointer-events: none !important;
}

/* =========================
   CLOSE TEXT SCANLINE (SAFE VERSION)
========================= */

#infoCloseBtn span {
  position: relative;
  z-index: 1;
}

#infoCloseBtn {
  overflow: hidden;
}

#infoCloseBtn::after {
  content: "";
  position: absolute;
  inset: 0;
  background: repeating-linear-gradient(
    to bottom,
    rgba(0,0,0,0.40) 0px,
    rgba(0,0,0,0.40) 1px,
    transparent 1px,
    transparent 2px
  );
  animation: closeScanMove 4s linear infinite;
  pointer-events: none;
  mix-blend-mode: multiply;
}

@keyframes closeScanMove {
  from { background-position-y: 0; }
  to   { background-position-y: 100%; }
}

/* =========================
   CLOSE BORDER SCANLINES
========================= */

#infoCloseBtn {
  --scan-color: rgba(0,0,0,0.40); /* æƒæç·šé¡è‰² */
  --scan-thick: 1px;             /* ç·šçš„åšåº¦ */
  --scan-gap: 2px;               /* ç·šèˆ‡ç·šçš„é–“éš” */
}

/* é‚Šæ¡†æƒæç·šï¼ˆå…§æ¡†ï¼‰ */
#infoCloseBtn::before {
  content: "";
  position: absolute;
  inset: 1px; /* å¾€å…§ç¸®ï¼Œè²¼è‘—é‚Šæ¡† */
  pointer-events: none;
  z-index: 0;

  background:
    repeating-linear-gradient(
      to bottom,
      var(--scan-color) 0,
      var(--scan-color) var(--scan-thick),
      transparent var(--scan-thick),
      transparent calc(var(--scan-thick) + var(--scan-gap))
    );

  mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  mask-composite: exclude;

  -webkit-mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;

  animation: closeBorderScan 5s linear infinite;
}

@keyframes closeBorderScan {
  from { background-position-y: 0; }
  to   { background-position-y: 100%; }
}

/* =========================
   INFO TITLE BAR + CLOSE
========================= */

.info-title-bar {
  display: flex;
  justify-content: space-between;
  align-items: baseline;

  margin-bottom: 6px;
}

/* åŸæœ¬æ¨™é¡Œç¶­æŒé¢¨æ ¼ */
.info-title {
  font-family: 'Courier Prime', monospace;
  font-size: 12px;
  letter-spacing: 1px;
}

/* [ Ã— ] é—œé–‰éµ */
.info-close {
  background: none;
  border: none;
  padding: 0;

  font-family: 'Courier Prime', monospace;
  font-size: 12px;
  letter-spacing: 1px;

  color: var(--color-ui-gold);
  cursor: pointer;

  position: relative;

  /* iOS ä¿éšª */
  pointer-events: auto !important;
  touch-action: manipulation !important;
}

/* æƒæç·šï¼ˆåªè“‹å­—ï¼‰ */
.info-close::after {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;

  background: repeating-linear-gradient(
    to bottom,
    rgba(0,0,0,0.35) 0px,
    rgba(0,0,0,0.35) 1px,
    transparent 1px,
    transparent 3px
  );

  animation: infoCloseScan 3.8s linear infinite;
  mix-blend-mode: multiply;
}

@keyframes infoCloseScan {
  from { background-position-y: 0; }
  to   { background-position-y: 100%; }
}
.info-close {
  line-height: 1;
}.hunter-toast {
  position: absolute;

  top: 6px;
  left: 50%;
  transform: translateX(-50%);

  background: #000;              /* âš ï¸ å¿…é ˆæ˜¯å¯¦å¿ƒé»‘ */
  border: 1px solid #c59d5f;
  padding: 6px 14px;

  overflow: hidden;
  z-index: 9999;
}

.hunter-toast {
  position: fixed;
  top: 22px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 2000;

  background: #000;
  border: 1px solid var(--color-ui-gold);
  padding: 6px 14px;
  overflow: hidden;
}

/* ğŸ‘‡ è·Ÿ info ä¸€æ¨£çš„æƒæç·šå±¤ */
.toast-scanlines {
  position: absolute;
  inset: 0;
  z-index: 2;
  pointer-events: none;

  background: repeating-linear-gradient(
    to bottom,
    rgba(0,0,0,0.35) 0px,
    rgba(0,0,0,0.35) 1px,
    transparent 1px,
    transparent 2px
  );

  animation: scanMove 4.5s linear infinite;
}

.toast-content {
  position: relative;
  z-index: 1;

  color: var(--color-ui-gold);
  font-family: 'Share Tech Mono', monospace;
  font-size: 12px;
  letter-spacing: 2px;

  text-shadow:
    0 1px rgba(255,255,255,0.12),
    0 2px rgba(0,0,0,0.35),
    0 3px rgba(255,255,255,0.06),
    0 4px rgba(0,0,0,0.25);

  animation: crtTextScan 3.5s linear infinite;
}

</style>
</head>
<body>

<div class="zero-terminal">
   <div class="term-header" id="mainHeader">
  <div class="header-left">
    <span id="sysLog">SYS.LOG_V10.8</span>
    <span id="mapToggle">[MAP: 01]</span>
  </div>

  <div class="header-right">
    <span id="infoToggle" class="info-disabled">[INFO]</span>
    <span id="diffToggle">[MODE: NORMAL]</span>
  </div>
</div>
    <div class="game-canvas-container" id="gameArea">
        <canvas id="gc"></canvas>
<!-- é€™è£¡ï¼šheader / canvas / overlay éƒ½åœ¨ -->


        
        <!-- å¼€å§‹ç•Œé¢ -->
        <div class="overlay" id="startScreen">
          <div class="term-title-small" id="dawnSecret">TARGET: DAWN</div>
          <p class="intro-text">
          WARNING: MULTIPLE HOSTILES.<br>
          <span id="modeText" style="color:#aaa; font-size:11px;">[CURRENT: STANDARD PROTOCOL]</span><br>
          <span id="mapText" style="color:#aaa; font-size:11px;">[MAP: CLASSIC]</span><br>
          <span id="warnText" style="color:#a31621; font-weight:bold;">DO NOT LET THEM CATCH YOU.</span>
          </p>
          <button class="btn-term" id="startBtn">RUN</button>
        </div>
 


        
        <!-- å¤±è´¥ç•Œé¢ -->
        <div class="overlay hidden" id="gameOverScreen">
          <h2 id="gameOverTitle" style="color:#555; font-size:12px; margin-bottom:15px; letter-spacing:2px; font-weight: normal; text-shadow: none;">// SYSTEM_INTERRUPT</h2>
          <p id="deathMsg"></p>
          <button class="btn-term" style="border-color:#444; color:#888;" id="retryBtn">STRUGGLE</button>
        </div>


        
        <!-- é¥¶æ•ç•Œé¢ (EASY) -->
        <div class="overlay hidden" id="mercyScreen">
          <h2 style="color:var(--color-safe-green); font-size:12px; margin-bottom:15px; letter-spacing:2px;">// MERCY_TRIGGERED</h2>
          <p id="mercyMsg" style="color:#aaa; border-left-color:var(--color-safe-green);"></p>
          <p style="font-size:10px; color:#555; margin-top:5px;">( ONE CHANCE USED )</p>
          <button class="btn-term" style="border-color:var(--color-safe-green); color:var(--color-safe-green);" id="escapeBtn">ESCAPE</button>
        </div>
        
        <!-- å‹åˆ©ä»‹é¢ -->
        <!-- å‹åˆ©ä»‹é¢ -->
        <div class="overlay hidden" id="winScreen">
            <h2 id="winTitle" style="color:var(--color-dawn); margin-bottom:10px; font-size:20px;">// FREEDOM_ACHIEVED</h2>
            <div id="winContent" style="color:#fff; font-size:12px; margin-bottom:15px; line-height:1.6; text-align:left; padding:0 10px;">
                > STATUS: ESCAPED<br>
                > THOUGHT: The cage is open.<br>
                <br>
                <span style="color:var(--color-ui-gold); font-style:italic;">"Run, Dawnie. Before they change their minds."</span>
            </div>
            <button class="btn-term" id="nextBtn">RUN AGAIN</button>
        </div>


  




    </div> <!-- é€™æ˜¯ game-canvas-container çš„çµæŸæ¨™ç±¤ -->
    
    <div class="status-line">
        <span>PROGRESS: <span id="score" class="score-val">0%</span></span>
<span id="hunterLivesUI" class="hidden"></span>
        <span>THREAT: <span id="threatLevel" style="color:var(--color-warn-gray)">LOW</span></span>
    </div>

<!-- âœ… INFO OVERLAY åœ¨é€™è£¡ï¼ï¼ -->
    <div id="infoOverlay" class="info-overlay hidden">
      <div class="info-window">
        <div class="info-title-bar">
  <div class="info-title">// SYSTEM INFO</div>
  <button id="infoCloseBtn" class="info-close">[ Ã— ]</button>
</div>
        <div class="info-content" id="infoContent"></div>
       
        <div class="info-scanlines"></div>
      </div>
    </div>


  </div>
</body>
   

<script>
// --- æ ¸å¿ƒå˜é‡ ---
const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');
const gameArea = document.getElementById('gameArea');
const COLS = 21;
const ROWS = 21;
let TILE_SIZE = 16;
let map = [];
let dots = new Set();
let totalDots = 0;
let score = 0;
let gameState = 'ready';
let animationId = null;
let difficulty = 'NORMAL'; 
let mercyUsed = false;   
// æ–°å¢ï¼šæŒ‰é”®çŠ¶æ€è¿½è¸ªï¼Œè§£å†³å»¶è¿Ÿ
let keys = {}; 
// === HUNTER MODE ===
let hunterUnlocked = false;
let hunterMode = false;
let dawnClickCount = 0;
let hunterAllies = [];
// === Hunter Lives System ===
let hunterLives = 3;          
let hunterHitCooldown = 0;    
const heatMap = {};
// === Hunter Survival Time ===
let hunterStartTime = 0;
let hunterSurviveTime = 0;
let hunterToastShown = false;
// ======================
// ğŸ”´ SEHEE TRAP SYSTEM
// ======================
let activeTrap = null; // åŒä¸€æ™‚é–“åªå­˜åœ¨ä¸€å€‹é™·é˜±

// ======================
// ğŸŸ£ LAURE CORROSION SYSTEM
// ======================
let corrosionTiles = new Map(); 
// key: "x,y" â†’ { expireTime }
let corruptionLevel = 0; // 0 ~ 3

// ======================
// â„¹ï¸ INFO SYSTEM
// ======================
let infoLevel = 0; // 0=ç¬¬ä¸€æ¬¡, 1=ç¬¬äºŒæ¬¡, 2=å®Œæ•´
const infoToggle = document.getElementById('infoToggle');
const infoOverlay = document.getElementById('infoOverlay');
const infoContent = document.getElementById('infoContent');
const infoCloseBtn = document.getElementById('infoCloseBtn');

const INFO_TEXT = {
  0: `> HUNTER MODE ONLINE

â€¢ You can consume enemies.
â€¢ Consumed enemies are converted into allies.
â€¢ Allies will attack hostile targets automatically.

â€¢ Convert all three targets to win.
â€¢ Do not let enemies consume all dots.

> You are no longer prey.
> You can fight back.`,

  2: `You think you are the hunter.
You are not.

â€¢ Converted allies will rebel after 3 seconds.
â€¢ Rebels return as enhanced enemies.

ENEMY ABILITIES:
â€¢ NICOLETTE â€” Execution protocol. 
â€¢ LAURE â€” Corrupted ground. 
â€¢ SEHEE â€” Deploys traps. 
â€¢ Dot consumption increases enemy strength.

PLAYER STATUS:
â€¢ Lives: 3
â€¢ Upon death: 3 seconds of invulnerability.

> Good luck.`
};

// --- åœ°å›¾æ•°æ® ---
const MAPS = {
  0: [ // MAP-01
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1],
    [1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ],
  1: [ // MAP-02
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
    [1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1], 
    [1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1], 
    [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1], 
    [1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1], 
    [1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1], 
    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], 
    [1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1], 
    [1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1], 
    [1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1], 
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1], 
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] 
  ],
  2: [ // MAP-03
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
    [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1],
    [1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
    [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ]
};

let currentMapIdx = 0;
const mapNames = ["CLASSIC", "SECTOR B", "SYMMETRY"];

const COLORS = {
    dawn: '#d4a017', nic: '#5a8fb4', laure: '#8e7cc3', sehee: '#b45a8f',
    wall: '#111111', wallBorder: '#2a2a2a', dot: '#a07812'
};
// ================================
// ğŸ¨ ENTITY STATE COLORS
// ================================
const ENTITY_COLORS = {
    ally: "#bfc3c7", // ğŸ¤ ç›Ÿå‹ï¼šç°ç™½

    enhanced: {
        nic:   "#4a4fb7", // æ·±è—
        laure: "#8c40bb", // æ·±ç´«
        sehee: "#d1005a"  // æ·±ç²‰ç´…
    }
};

const QUOTES_EARLY = {
    nic: ["Too slow.", "I have you. Don't make this complicated.", "Stop wasting my time with these games.", "That's enough running.", "Effortless.","Try harder next time."],
    sehee: ["Caught you! slowpoke! :p", "Hug attack!", "Gotcha!","I win again! You suck at this!","Did you trip? Hahaha.","Easy peasy! You're losing your touch!"],
    laure: ["How rude to make a lady chase you.", "A futile effort. You look exhausted.", "How predictable.","A distinctive lack of grace. Unfortunate.","Your technique is sloppy. I expected more.","I do admire the effort. Truly."]
};
const QUOTES_MID = {
    nic: ["Enough. We need to talk.", "You're scared. I can see it. Let me handle it.", "I'm losing my temper. Don't push me further.", "Don't make me do something we'll both regret.", "I don't want to lose you. Not like this.","Just... stay. We can figure this out."],
    sehee: ["I don't wanna be alone again! Please!", "I'll let go if you promise not to run! ...No, wait, I won't!", "I'll bite you if you struggle! I mean it!", "It's not funny anymore! Come back!", "Why are you leaving?! Don't you like me anymore?!","Hey! That actually hurt!"],
    laure: ["I am trying to be patient. Do not waste it.", "I don't want to hurt you. Please believe that.", "I don't want to force you...", "Ma chÃ©rie, please. Let's talk about this.","Why do you resist? I can give you everything.","Do not turn your back on me. It insults me."]
};
const QUOTES_LATE = {
    nic: ["I've killed for less. Don't test me.", "You will never escape me.", "You're not leaving. I won't allow it.", "Don't you DARE try that again.", "You're mine. I don't care if you fight it.","I'll burn this entire city down before I lose you."],
    sehee: ["I'll follow you to HELL! You're NOT escaping!", "I'd rather we BOTH DIE than let you run! :)", "Hahahaha! We're going to rot here together! Forever!", "Who are you running to?! I'll kill them too!", "CAUGHT YOU! Hah! You really thought you'd get away?","You made me so fucking mad."],
    laure: ["Caught. You think you have a choice? How adorable.", "You will stay. Or I will make you wish you had.", "You are mine. By law, by force, by right. Accept it.", "You want to be free? I will destroy your very will to exist.", "You are PROPERTY. Do not forget what you are.","Your life outside ends today."]
};
const QUOTES_EXTREME = {
    nic: ["You belong on a leash, right at my feet. Good girl.", "You compromised my patience. Now I'm going to dismantle your resistance, finger by finger.", "Target secured. Initiating punishment protocol. Strip.", "No more games. I'll pin you down and grind against you until your mind goes blank.","You think you can just LEAVE? After everything? I'm going to fuck the defiance right out of you.","On your knees. Now. Show me you know who owns you."],
    sehee: ["Found you~! Now I get to break my favorite toy! :p", "You're mine! I'll fuck you in front of everyone! I don't care!", "Let's play a game: try not to cum while I break you! :)", "I'm so pissed off! I'm gonna fuck you until you bleed!","Hahaha! You're so wet! Did you miss me? Or are you just scared?!","I'm gonna lick you until you pass out, then wake you up and do it again!"],
    laure: ["Dirty little stray. I'm going to fuck you until you forget your own name.", "Beg me to stop. I want to hear how desperate you can get.", "You should be grateful I'm touching you at all. Now say 'thank you, Mistress'.", "Look at you, groveling in the dirt. You need to be reminded of your place.","I'll leave you messy and used on the floor. That's all you're worth.","Je tâ€™ai attrapÃ©e. Be a good pet and spread for me. That's it."]
};
const QUOTES_MERCY = {
    nic: ["This is your one chance.", "Consider this a training exercise. Dismissed.", "I can't believe I'm doing this...","Your flank is open. I'm letting you go. Correct it.","You're lucky today. Don't push your luck.","Before I change my mind. Move."],
    sehee: ["Ow ow ow! Fine! Go! But I'm coming after you!", "Okay okay, I let you go! But only because I'm nice!", "1, 2, 3... I'm giving you a head start!","Bye bye! Don't die out there!","Ugh, I'm bored now. You can go.","Hah! You're fast! I like it! Run, Dawnie!"],
    laure: ["Go. I'm feeling generous today.", "You look pathetic. Go clean yourself up.", "A moment of grace. Use it wisely.","Run along, stray. The gate is open.","You may leave. Show me a better performance next time.","Freedom is a heavy burden. See if you can carry it."]
};
// ================================
// ğŸ”¥ ENHANCED ENEMY THREATS
// ================================

// ğŸ”µ Nicolette
const ENHANCED_THREATS_NIC = [
  "NICOLETTE: This ends now.",
  "NICOLETTE: You are out of options.",
  "NICOLETTE: Stop running."
];

// ğŸŸ£ Laure
const ENHANCED_THREATS_LAURE = [
  "LAURE: You shouldnâ€™t walk so hastily.",
  "LAURE: Chose your path wisely.",
  "LAURE: It is impolite to have a lady chase you."
];

// ğŸ”´ Sehee â€” æ”¾ç‚¸å½ˆ
const ENHANCED_THREATS_SEHEE_TRAP = [
  "SEHEE: I prepared a gift for you:p",
  "SEHEE: Step carefully, okay?",
  "SEHEE: GOGOGO! Donâ€™t miss it!"
];

// ğŸ’¥ Sehee â€” çˆ†ç‚¸
const ENHANCED_THREATS_SEHEE_BOOM = [
  "SEHEE: BOOM! Did that hurt?",
  "SEHEE: Oops~ too late!",
  "SEHEE: Awww, you saw it, right?"
];
function randomFrom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

const VICTORY_TEXTS = {
    // EASY MODE: å›°æƒ‘èˆ‡åƒ¥å€– 
    easy: {
        title: "// ...THEY STOPPED?",
        status: "BREATHING",
        thought: "I don't know why. I don't care.",
        quote: "\"Just keep moving. Don't ask questions. Just go.\"",
        color: "#4caf50"  
    },
    // NORMAL MODE: é©šé­‚æœªå®š -
    normal: {
        title: "// SHIT... I MADE IT.",
        status: "ALIVE",
        thought: "My hands are shaking. But I'm out.",
        quote: "\"Don't look back. If I look back, they'll be there.\"",
        color: "#d4a017" 
    },
    // HARD MODE: åŠ«å¾Œé¤˜ç”Ÿ -
    hard: {
        title: "// HOW AM I STILL HERE?",
        status: "SURVIVED",
        thought: "They wanted to keep me. Really keep me.",
        quote: "\"I thought... I thought I was gone for sure. Never again.\"",
        color: "#a31621"  
    },

// HUNTER MODE: çµäººå‹åˆ©
    hunter: {
  title: "// ...REALLY?",
  status: "CONTROL ACHIEVED",
  thought: "They stopped fighting. That scares me more than before...",
  quote: "\"They followed because I made them. Not because they wanted to.\"",
  color: "#d6b36a"
}
};

class Entity {
    constructor(x, y, color, type) {
        this.gridX = x; this.gridY = y;
        this.pixelX = x * TILE_SIZE; this.pixelY = y * TILE_SIZE;
        this.color = color;
        this.type = type;
        this.dir = {x:0, y:0};
        this.nextDir = {x:0, y:0};
        this.moving = false;
this.decisionCooldown = 0;
this.targetDot = null;
this.isAfraid = false;
this.loopCounter = 0;
this.lastGridPos = null;
this.recentTiles = [];
this.panicTimer = 0;
this.spawnScatterTimer = 0;
this.spawnTarget = null;

        
        // Hunter Mode å±¬æ€§
        this.isAlly = false;
        this.isMarked = false;
        this.markTime = 0;
        this.speedMultiplier = 1.0;
this.isEnhanced = false; 
// ğŸ”´ Sehee Trap
this.trapCooldown = 0;
this.trapInterval = 600; // ç´„ 10 ç§’ï¼ˆthink æ¬¡æ•¸ï¼‰

        
        // ğŸ”µ Nicolette Execute
this.executeCooldown = 0;
this.executeDuration = 0;
this.isExecuteMode = false;
this.executeInterval = 600; // ç´„ 10 ç§’ï¼ˆthink æ¬¡æ•¸ï¼‰

if (this.type === "player") {
    this.speed = 0.18;

    // Hunter ç‹€æ…‹ç”¨ï¼ˆplayer å°ˆå±¬ï¼‰
    this.hurtFlashTime = 0;
// ğŸŸ£ Corrosion effect (player only)
this.corrosionStack = 0;
this.corrosionSlowTimer = 0;
    // å¦‚æœä½ ä¹‹å¾Œè¦ç”¨ï¼Œä¹Ÿå¯ä»¥å…ˆæ”¾è‘—
    // this.isInvincible = false;
}else {
  // æå‡åŸºç¤é€Ÿåº¦ï¼
  if (this.type === 'nic') this.baseSpeed = 0.13;      // å¾ 0.10 æå‡
  else if (this.type === 'laure') this.baseSpeed = 0.12; // å¾ 0.09 æå‡
  else this.baseSpeed = 0.14;                          // sehee å¾ 0.11 æå‡
  
  // ä¿ç•™åŸæœ¬çš„é›£åº¦ä¹˜ç‡
  if (difficulty === 'EASY') {
    this.baseMultiplier = 0.55;  // EASY åŸæœ¬å°±æ˜¯ 55%
  } else if (difficulty === 'HARD') {
    this.baseMultiplier = 1.0;   // HARD åŸæœ¬å°±æ˜¯ 100%
  } else {
    this.baseMultiplier = 1.0;   // NORMAL åŸæœ¬ä¹Ÿæ˜¯ 100%
  }
  
  // åˆå§‹é€Ÿåº¦ï¼ˆç¨å¾Œæœƒåœ¨ update() ä¸­åŠ ä¸Šå‹•æ…‹åŠ é€Ÿï¼‰
  this.speed = this.baseSpeed * this.baseMultiplier;
}
        this.lastMove = {x:0, y:0};

// ğŸ”’ AI æ±ºç­–é–ï¼ˆä¸€æ¬¡é€²ä¸€æ ¼ï¼Œåªæƒ³ä¸€æ¬¡ï¼‰
this.hasDecision = false;
// ğŸ§¬ å€‹é«”å·®ç•°ï¼ˆé˜²æ­¢ç¾¤èšï¼‰
this.personalityBias = Math.random() * 0.6 - 0.3;
this.lastChoiceCooldown = 0;
    }
    
    update() {
    if(gameState !== 'playing') return;
    
    // === EASY/NORMAL/HARD æ¨¡å¼å‹•æ…‹åŠ é€Ÿï¼šåŸºæ–¼éŠæˆ²é€²åº¦ ===
    // åªå°é€™ä¸‰å€‹æ¨¡å¼ç”Ÿæ•ˆ
    if(
  this.type !== 'player' &&
  !hunterMode &&   // ğŸ‘ˆ Hunter Mode å®Œå…¨é—œæ‰ã€Œåƒè±†å­åŠ é€Ÿã€
  (difficulty === 'EASY' || difficulty === 'NORMAL' || difficulty === 'HARD')
) {
        
        const progress = totalDots > 0 ? (score / totalDots) : 0;
        
        // å‹•æ…‹åŠ é€Ÿå€ç‡ï¼ˆç–ŠåŠ åœ¨åŸæœ¬çš„é›£åº¦ä¹˜ç‡ä¸Šï¼‰
        let dynamicMultiplier = 1.0;
        
        if (difficulty === 'EASY') {
            // EASYï¼šå¾åŸæœ¬çš„ 55% é–‹å§‹ï¼Œé€æ¼¸åŠ é€Ÿ
            dynamicMultiplier = 1.0 + progress * 0.5;  // 55% â†’ 82.5%
        } else if (difficulty === 'HARD') {
            // HARDï¼šå¾åŸæœ¬çš„ 100% é–‹å§‹ï¼Œå¿«é€ŸåŠ é€Ÿ
            dynamicMultiplier = 1.0 + progress * 0.7;  // 100% â†’ 170%
        } else {
            // NORMALï¼šå¾åŸæœ¬çš„ 100% é–‹å§‹ï¼Œä¸­ç­‰åŠ é€Ÿ
            dynamicMultiplier = 1.0 + progress * 0.3;  // 100% â†’ 130%
        }
        
        // æ‡‰ç”¨å‹•æ…‹åŠ é€Ÿï¼ˆåŸºç¤é€Ÿåº¦ Ã— åŸæœ¬é›£åº¦ä¹˜ç‡ Ã— å‹•æ…‹åŠ é€Ÿï¼‰
        this.speed = this.baseSpeed * this.baseMultiplier * dynamicMultiplier;
    }

        
// === ä¿®å¾©ï¼šæº«å’Œçš„é æ¸¬è½‰å½ï¼Œé˜²æ­¢ç¬ç§» ===
if (this.type === 'player') {

    let progressToTarget = 0;
    const targetPixelX = this.gridX * TILE_SIZE;
    const targetPixelY = this.gridY * TILE_SIZE;

    if (this.dir.x !== 0) {
        const distance = Math.abs(this.pixelX - targetPixelX);
        progressToTarget = distance / TILE_SIZE;
    } else if (this.dir.y !== 0) {
        const distance = Math.abs(this.pixelY - targetPixelY);
        progressToTarget = distance / TILE_SIZE;
    }

    // é æ¸¬è½‰å½ï¼ˆåªçµ¦ playerï¼‰
    if (this.nextDir.x !== 0 || this.nextDir.y !== 0) {
        const nextX = this.gridX + this.nextDir.x;
        const nextY = this.gridY + this.nextDir.y;

        if (!isWall(nextX, nextY) && progressToTarget > 0.85) {
            this.dir = { ...this.nextDir };
            this.nextDir = { x: 0, y: 0 };
            this.lastMove = { ...this.dir };
        }
    }

    // åƒè±†å­ï¼ˆåªçµ¦ playerï¼‰
    const currentKey = `${this.gridX},${this.gridY}`;
    if (!hunterMode && dots.has(currentKey)) {
        dots.delete(currentKey);
        score++;
        document.getElementById('score').innerText =
            Math.floor((score / totalDots) * 100) + '%';
        updateThreatLevel();
        if (dots.size === 0) endGame(true);
    }
}
        
        const distToGridX = Math.abs(this.pixelX - this.gridX * TILE_SIZE);
        const distToGridY = Math.abs(this.pixelY - this.gridY * TILE_SIZE);
        
        if(distToGridX < 2.0 && distToGridY < 2.0) {
            this.pixelX = this.gridX * TILE_SIZE;
            this.pixelY = this.gridY * TILE_SIZE;
            
            if(this.type === 'player') {
                if(this.nextDir.x !== 0 || this.nextDir.y !== 0) {
                    const targetX = this.gridX + this.nextDir.x;
                    const targetY = this.gridY + this.nextDir.y;
                    
                    if(!isWall(targetX, targetY)) {
                        this.dir = {...this.nextDir};
                        this.nextDir = {x:0, y:0};
                    }
                }
            }
            
            const nextX = this.gridX + this.dir.x;
            const nextY = this.gridY + this.dir.y;
            
            if(!isWall(nextX, nextY)) {
    this.moving = true;
    this.gridX = nextX;
    this.gridY = nextY;
    this.lastMove = {...this.dir};

const key = `${this.gridX},${this.gridY}`;
this.recentTiles.push(key);
if (this.recentTiles.length > 8) this.recentTiles.shift();

    // ğŸ”“ é€²å…¥æ–°æ ¼å­å¾Œï¼Œå…è¨± AI å†æ¬¡æ€è€ƒ
    this.hasDecision = false;

const posKey = `${this.gridX},${this.gridY}`;

// âœ… åªæœ‰ã€ŒçœŸçš„é€²å…¥æ–°æ ¼å­ã€æ‰ç•™è…è•
if (this.lastGridPos !== posKey) {

    // ğŸŸ£ Laure corrosion â€” once per tile
    if (
        hunterMode &&
        this.isEnhanced &&
        this.type === 'laure'
    ) {
        if (!isWall(this.gridX, this.gridY)) {
            corrosionTiles.set(posKey, {
                expireTime: Date.now() + (2500 + corruptionLevel * 1000)
            });
if (!laureSubtitleShown) {
    showThreatSubtitle(
   randomFrom(ENHANCED_THREATS_LAURE),

    2200,
    "rgba(80,40,120,0.35)"
);
    laureSubtitleShown = true;
}
        }
    }

    this.loopCounter = 0;
} else {
    this.loopCounter++;
}

this.lastGridPos = posKey;
}else {
    this.moving = false;
}
        }
        
        if (this.moving) {
    const spd = this.speed * (this.speedMultiplier || 1);

    const targetX = this.gridX * TILE_SIZE;
    const targetY = this.gridY * TILE_SIZE;

    const step = TILE_SIZE * spd;

this.pixelX = Math.abs(targetX - this.pixelX) < step
    ? targetX
    : this.pixelX + this.dir.x * step;

this.pixelY = Math.abs(targetY - this.pixelY) < step
    ? targetY
    : this.pixelY + this.dir.y * step;

    // ğŸ©¹ é˜²æ­¢ overshootï¼ˆé—œéµæ­¢è¡€ï¼‰
    if (
        (this.dir.x !== 0 &&
         Math.sign(targetX - this.pixelX) !== Math.sign(this.dir.x)) ||
        (this.dir.y !== 0 &&
         Math.sign(targetY - this.pixelY) !== Math.sign(this.dir.y))
    ) {
        this.pixelX = targetX;
        this.pixelY = targetY;
        this.moving = false;
    }
}

// ğŸŸ£ Corrosion effect on Hunter
if (hunterMode) {

    const px = Math.floor((this.pixelX + TILE_SIZE / 2) / TILE_SIZE);
    const py = Math.floor((this.pixelY + TILE_SIZE / 2) / TILE_SIZE);
    const key = `${px},${py}`;

    if (hunterMode && this.type === 'player') {
    

if (corrosionTiles.has(key)) {
        this.corrosionStack += 1;
    } else {
        this.corrosionStack = Math.max(0, this.corrosionStack - 1);
    }

    if (this.corrosionStack >= 60) {
        this.corrosionSlowTimer = 120;
        this.corrosionStack = 0;
    }

    if (this.corrosionSlowTimer > 0) {
        this.corrosionSlowTimer--;
        this.speedMultiplier = 0.6;
    } else {
        // âœ… é—œéµï¼šæ¢å¾©æ­£å¸¸é€Ÿåº¦
        this.speedMultiplier = 1.0;
    }
}
    
if (this.decisionCooldown > 0) {
    this.decisionCooldown--;
}
}

}

    draw() {

    let glowColor = this.color;
    let glowBlur  = 0;
    let fillColor = this.color;

    // =========================
    // ğŸ¤ ALLYï¼ˆæœ€é«˜å„ªå…ˆï¼Œä»»ä½• type éƒ½å…ˆæ“‹ï¼‰
    // =========================
    if (this.isAlly) {

        ctx.fillStyle   = ENTITY_COLORS.ally;
        ctx.shadowColor = "rgba(170,175,180,0.5)"; // å¾ˆæ·¡ï¼Œä¸åƒæ•µäºº
        ctx.shadowBlur  = 7; // æˆ– 0 = å®Œå…¨æ²’å…‰

        ctx.fillRect(
            this.pixelX + 3,
            this.pixelY + 3,
            TILE_SIZE - 6,
            TILE_SIZE - 6
        );

        ctx.shadowBlur = 0;
        return; // â›” çµ•å°ä¸å†å¾€ä¸‹èµ°
    }

    // =========================
    // ğŸ§‘ PLAYER
    // =========================
    if (this.type === "player") {

        // ğŸŸ¦ Hunter I-Frameï¼šç›Ÿå‹è‰²è„ˆå‹•ï¼ˆè¶Šä¾†è¶Šå¿«ï¼‰
        if (hunterMode && hunterHitCooldown > 0) {

            const t = hunterHitCooldown / 120;   // 1 â†’ 0
            const pulseSpeed = 2 + (1 - t) * 8;
            const pulse =
                (Math.sin(performance.now() * 0.001 * pulseSpeed) + 1) * 0.5;

            fillColor = mixColor(
                this.color,
                ENTITY_COLORS.ally,
                0.4 + pulse * 0.4
            );

            glowColor = ENTITY_COLORS.ally;
            glowBlur  = 12 + pulse * 18;

        } else {
            fillColor = this.color;
            glowColor = "rgba(245, 235, 210, 0.6)";
            glowBlur  = 7;
        }

    // =========================
    // ğŸ‘¿ ENHANCED ENEMY
    // =========================
    } else if (this.isEnhanced) {

        glowBlur = 14;

        if (this.type === 'nic' && this.isEnhanced && this.isExecuteMode) {

    const pulse =
        (Math.sin(performance.now() * 0.001 * 6) + 1) * 0.5;

    fillColor = mixColor(
        this.color,              // â† åŸæœ¬çš„ #4a4fb7
        "#9fdcff",               // â† äº®è—ï¼Œåªæ‹¿ä¾†è„ˆè¡
        0.35 + pulse * 0.35
    );

    glowColor = "rgba(160,220,255,0.9)";
    glowBlur  = 12 + pulse * 18;
} else if (this.type === "laure") {
            glowColor = "rgba(120, 40, 180, 0.85)";
        } else if (this.type === "sehee") {
            glowColor = "rgba(180, 30, 30, 0.9)";
        }

    // =========================
    // ğŸ‘¾ NORMAL ENEMY
    // =========================
    } else {

        glowBlur = 7;

        if (this.type === "nic") {
            glowColor = "rgba(60, 90, 200, 0.85)";
        } else if (this.type === "laure") {
            glowColor = "rgba(120, 70, 160, 0.85)";
        } else if (this.type === "sehee") {
            glowColor = "rgba(160, 60, 120, 0.85)";
        }
    }

    // =========================
    // ğŸ¨ DRAWï¼ˆå…±ç”¨ï¼‰
    // =========================
    ctx.fillStyle   = fillColor;
    ctx.shadowColor = glowColor;
    ctx.shadowBlur  = glowBlur;

    ctx.fillRect(
        this.pixelX + 3,
        this.pixelY + 3,
        TILE_SIZE - 6,
        TILE_SIZE - 6
    );

    ctx.shadowBlur = 0;
}

    // ================================
    // ğŸ§  æ™®é€šæ¨¡å¼ AIï¼ˆåŸæœ¬å¾ˆå…‡çš„é‚£å¥—ï¼‰
    // ================================
    useNormalAI() {

        if (
            Math.abs(this.pixelX - this.gridX * TILE_SIZE) > 1.5 ||
            Math.abs(this.pixelY - this.gridY * TILE_SIZE) > 1.5
        ) {
            return;
        }

        const dirs = [
            {x:0,y:-1},
            {x:0,y:1},
            {x:-1,y:0},
            {x:1,y:0}
        ];

        let valid = dirs.filter(d => !isWall(this.gridX + d.x, this.gridY + d.y));

// ğŸ”„ å¡å¾ªç’°å°±å…è¨±å›é ­ä¸€æ¬¡
if (this.loopCounter > 4) {
    valid = dirs.filter(d =>
        !isWall(this.gridX + d.x, this.gridY + d.y)
    );
    this.loopCounter = 0;
}

        // ç¦æ­¢ç«‹åˆ»å›é ­ï¼ˆé™¤éæ­»è·¯ï¼‰
        if (valid.length > 1) {
            valid = valid.filter(d =>
                !(d.x === -this.lastMove.x && d.y === -this.lastMove.y)
            );
        }

        if (valid.length === 0) return;

        // === å„è§’è‰²ç‰¹è‰² ===
        if (this.type === 'nic') {
            valid.sort((a, b) => {
                const da =
                    Math.abs(this.gridX + a.x - player.gridX) +
                    Math.abs(this.gridY + a.y - player.gridY);
                const db =
                    Math.abs(this.gridX + b.x - player.gridX) +
                    Math.abs(this.gridY + b.y - player.gridY);
                return da - db;
            });
            this.dir = valid[0];

        } else if (this.type === 'laure') {
            const targetX = player.gridX + player.dir.x * 4;
            const targetY = player.gridY + player.dir.y * 4;

            valid.sort((a, b) => {
                const da =
                    Math.abs(this.gridX + a.x - targetX) +
                    Math.abs(this.gridY + a.y - targetY);
                const db =
                    Math.abs(this.gridX + b.x - targetX) +
                    Math.abs(this.gridY + b.y - targetY);
                return da - db;
            });
            this.dir = valid[0];

        } else if (this.type === 'sehee') {
            if (Math.random() < 0.2) {
                valid.sort((a, b) => {
                    const da =
                        Math.abs(this.gridX + a.x - player.gridX) +
                        Math.abs(this.gridY + a.y - player.gridY);
                    const db =
                        Math.abs(this.gridX + b.x - player.gridX) +
                        Math.abs(this.gridY + b.y - player.gridY);
                    return da - db;
                });
                this.dir = valid[0];
            } else {
                this.dir = valid[Math.floor(Math.random() * valid.length)];
            }
        }

        this.lastMove = { ...this.dir };
        this.hasDecision = true;
        this.decisionCooldown = 6;
    }
    
  think() {

    // ===== PLAYER ä¸éœ€è¦ AI =====
    if (this.type === 'player') return;


// ===================================
// ğŸ”´ SEHEE TRAP ABILITY
// ===================================
if (
    hunterMode &&
    this.isEnhanced &&
    this.type === 'sehee'
) {
    if (this.trapCooldown > 0) {
        this.trapCooldown--;
    } else if (!activeTrap) {

        // éš¨æ©Ÿæ‰¾ä¸€å€‹ã€Œä¸æ˜¯ç‰†ã€çš„æ ¼å­
        let tries = 30;
        while (tries-- > 0) {
            const tx = Math.floor(Math.random() * COLS);
            const ty = Math.floor(Math.random() * ROWS);

            if (!isWall(tx, ty)) {
                activeTrap = {
                    x: tx,
                    y: ty,
                    expireTime: Date.now() + (7000 - corruptionLevel * 600),
                    triggered: false
                };
showThreatSubtitle(
  randomFrom(ENHANCED_THREATS_SEHEE_TRAP),
  1800,
  "rgba(120,20,20,0.35)"
);
                break;
            }
        }

        this.trapCooldown = this.trapInterval;
    }
}

// ===================================
// ğŸ”µ NICOLETTE EXECUTE MODE
// ===================================
if (
    hunterMode &&
    this.isEnhanced &&
    this.type === 'nic'
) {
    if (this.executeCooldown > 0) {
        this.executeCooldown--;
    } else if (!this.isExecuteMode) {

        // å•Ÿå‹•å¿…æ®º
        this.isExecuteMode = true;
this.executeDuration = 120;
this.executeCooldown =
    this.executeInterval * (1 - corruptionLevel * 0.15);

showThreatSubtitle(
    randomFrom(ENHANCED_THREATS_NIC),
  
    1600,
    "rgba(40,80,120,0.35)"
);
    }

    if (this.isExecuteMode) {
        this.executeDuration--;
        if (this.executeDuration <= 0) {
            this.isExecuteMode = false;
        }
    }
}

// ===================================
// ğŸ©¸ ENHANCED ENEMYï¼šæ²¿ç”¨æ­£å¸¸æ¨¡å¼ AI
// ===================================
if (hunterMode && this.isEnhanced) {
    this.useNormalAI();      // â† é—œéµ
    this.speedMultiplier = 1.1;
    return;
}

const forwardX = this.gridX + this.dir.x;
const forwardY = this.gridY + this.dir.y;

// å‰é¢æ˜¯ç‰† â†’ ä¸€å®šè¦é‡æ–°é¸æ–¹å‘
const mustTurn = isWall(forwardX, forwardY);

// â—å¦‚æœé‚„æ²’é–‹å§‹ç§»å‹•ï¼Œå…è¨±æ€è€ƒï¼ˆçµ¦åˆå§‹æ¨åŠ›ï¼‰
if (!hunterMode) {
    if (
        this.dir.x !== 0 || this.dir.y !== 0
    ) {
        // ä¸æ˜¯äº¤å‰å£ï¼Œä½†å‰é¢æ˜¯ç‰† â†’ ä¸€å®šè¦æƒ³
if (
    !isIntersection(this.gridX, this.gridY) &&
    !mustTurn
) {
    return;
}
    }
}
// ğŸ”¥ åŠ å¼·ç‰ˆæ•µäººï¼šä¸ä½¿ç”¨å†·å»é–
if (hunterMode && this.isEnhanced) {
    this.decisionCooldown = 0;
    this.hasDecision = false;
}
else if (hunterMode && this.decisionCooldown > 0 && !this.isAfraid) {
    return;
}

    // ğŸ”’ å·²ç¶“åšéæ±ºç­–ï¼Œå°±ç­‰èµ°é€²ä¸‹ä¸€æ ¼
// âš ï¸ Hunter æ¨¡å¼ä¾‹å¤–ï¼Œå…è¨±é‡æ–°åˆ¤æ–·
if (this.hasDecision && !hunterMode) return;
  

// ğŸ‘» HUNTER MODE - NORMAL ENEMY (STATE AI)
// =======================================
if (hunterMode && !this.isEnhanced && !this.isAlly) {



    // å¿…é ˆåœ¨æ ¼å­ä¸­å¿ƒ
    if (
        Math.abs(this.pixelX - this.gridX * TILE_SIZE) > 1.5 ||
        Math.abs(this.pixelY - this.gridY * TILE_SIZE) > 1.5
    ) {
        return;
    }

// ğŸ§¨ SPAWN SCATTERï¼šé–‹å±€å¼·åˆ¶åˆ†æ•£ï¼Œé¿å…è¢«ç§’åƒ
if (this.spawnScatterTimer > 0) {
    this.spawnScatterTimer--;

    const dirs = [
        {x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}
    ];

    let valid = dirs.filter(d =>
        !isWall(this.gridX + d.x, this.gridY + d.y)
    );

    if (valid.length > 1) {
        valid = valid.filter(d =>
            !(d.x === -this.lastMove.x && d.y === -this.lastMove.y)
        );
    }

// ğŸ§¯ STUCK RECOVERYï¼šå¡ä½å¤ªä¹…å°±å¼·åˆ¶é‡æƒ³
if (this.loopCounter >= 2) {
    this.hasDecision = false;
    this.decisionCooldown = 0;
}

    // ğŸš« é é›¢ç©å®¶ï¼ˆä½†ä¸æ˜¯ææ…Œï¼‰
    valid.sort((a, b) => {
        const da =
            Math.abs(this.gridX + a.x - player.gridX) +
            Math.abs(this.gridY + a.y - player.gridY);
        const db =
            Math.abs(this.gridX + b.x - player.gridX) +
            Math.abs(this.gridY + b.y - player.gridY);
        const diff = db - da;
if (Math.abs(diff) < 0.1) {
    return Math.random() - 0.5; // ğŸ‘ˆ å¹³æ‰‹æ™‚äº‚ä¸€ä¸‹
}
return diff + this.personalityBias;
    });

    this.dir = valid[0];
    this.lastMove = {...this.dir};
    this.hasDecision = true;
    this.decisionCooldown = 2;
    return;
}

// ğŸš§ WALL ESCAPEï¼šåªè¦å‰é¢æ˜¯ç‰†ï¼Œç«‹åˆ»æ›æ–¹å‘
const fx = this.gridX + this.dir.x;
const fy = this.gridY + this.dir.y;

if (isWall(fx, fy)) {

    const dirs = [
        {x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}
    ];

    let options = dirs.filter(d =>
        !isWall(this.gridX + d.x, this.gridY + d.y)
    );

    // ç›¡é‡ä¸è¦ç«‹åˆ»å›é ­
    if (options.length > 1) {
        options = options.filter(d =>
            !(d.x === -this.lastMove.x && d.y === -this.lastMove.y)
        );
    }

    if (options.length > 0) {
        this.dir = options[Math.floor(Math.random() * options.length)];
        this.lastMove = {...this.dir};
        this.hasDecision = true;
        this.decisionCooldown = 2;
        return;
    }
}

// ğŸŒ€ VIRTUAL INTERSECTIONï¼šç›´ç·šèµ°å¤ªä¹…ï¼Œå‡è£æ˜¯äº¤å‰å£
if (this.loopCounter >= 3) {

    const dirs = [
        {x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}
    ];

    let options = dirs.filter(d =>
        !isWall(this.gridX + d.x, this.gridY + d.y)
    );

    if (options.length > 1) {
        options = options.filter(d =>
            !(d.x === -this.lastMove.x && d.y === -this.lastMove.y)
        );
    }

    if (options.length > 0) {
        this.dir = options[Math.floor(Math.random() * options.length)];
        this.lastMove = {...this.dir};
        this.hasDecision = true;
        this.loopCounter = 0;
        return;
    }
}

    const FEAR_RANGE = 999;

    const distToPlayer =
        Math.abs(this.gridX - player.gridX) +
        Math.abs(this.gridY - player.gridY);

    const dirs = [
        {x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}
    ];

    let valid = dirs.filter(d =>
        !isWall(this.gridX + d.x, this.gridY + d.y)
    );

    // æ­»è·¯å…è¨±å›é ­
    if (valid.length > 1) {
        valid = valid.filter(d =>
            !(d.x === -this.lastMove.x && d.y === -this.lastMove.y)
        );
    }

    // ğŸ˜¨ PANICï¼šç©å®¶å¾ˆè¿‘ï¼ˆææ…ŒåŠ é€Ÿï¼Œæœ‰æ…£æ€§ï¼‰
if (distToPlayer <= FEAR_RANGE) {

    this.panicTimer = 6; // ğŸ‘ˆ é—œéµï¼šææ…Œè‡³å°‘æŒçºŒ 6 æ¬¡ think
    this.speedMultiplier = 1.2;

    valid.sort((a, b) => {
        const da =
            Math.abs(this.gridX + a.x - player.gridX) +
            Math.abs(this.gridY + a.y - player.gridY);
        const db =
            Math.abs(this.gridX + b.x - player.gridX) +
            Math.abs(this.gridY + b.y - player.gridY);
        const diff = db - da;
if (Math.abs(diff) < 0.1) {
    return Math.random() - 0.5; // ğŸ‘ˆ å¹³æ‰‹æ™‚äº‚ä¸€ä¸‹
}
return diff;
    });

    this.dir = valid[0];
    this.lastMove = {...this.dir};
    this.hasDecision = true;
    this.decisionCooldown = 3;
    return;
}
// ğŸ˜®â€ğŸ’¨ å†·éœä¸‹ä¾†
if (this.panicTimer > 0) {
    this.panicTimer--;
    this.speedMultiplier = 1.35;
} else {
    this.speedMultiplier = 1.0;
}
    // =====================
    // ğŸŸ¡ GREEDï¼šåƒè±†å­
    // =====================
    const dotDir = findNearestDotDir(this);
    if (dotDir) {
        this.dir = dotDir;
        this.lastMove = {...this.dir};
        this.hasDecision = true;
        return;
    }

    // ğŸ§­ WANDERï¼šæ¢ç´¢ï¼ˆè¨å­æœ€è¿‘èµ°éçš„åœ°æ–¹ï¼‰
valid.sort((a, b) => {
    const ka = `${this.gridX + a.x},${this.gridY + a.y}`;
    const kb = `${this.gridX + b.x},${this.gridY + b.y}`;

    const ra = this.recentTiles.includes(ka) ? 1 : 0;
    const rb = this.recentTiles.includes(kb) ? 1 : 0;

    return ra - rb + (Math.random() - 0.5) * 0.2;
});

this.dir = valid[0];
this.lastMove = {...this.dir};
this.hasDecision = true;
return;
}
// ===================================
// ğŸ¤ HUNTER MODE - ALLY AI
// ===================================
if (hunterMode && this.isAlly) {

    // å¿…é ˆåœ¨æ ¼å­ä¸­å¿ƒ
    if (
        Math.abs(this.pixelX - this.gridX * TILE_SIZE) > 1.5 ||
        Math.abs(this.pixelY - this.gridY * TILE_SIZE) > 1.5
    ) {
        return;
    }

    if (enemies.length === 0) return;

    let target = null;
    let bestDist = Infinity;

    enemies.forEach(e => {
        const d =
            Math.abs(this.gridX - e.gridX) +
            Math.abs(this.gridY - e.gridY);
        if (d < bestDist) {
            bestDist = d;
            target = e;
        }
    });

    if (!target) return;

    const dirs = [
        {x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}
    ];

    let valid = dirs.filter(d =>
        !isWall(this.gridX + d.x, this.gridY + d.y)
    );

    // ç¦æ­¢ç«‹åˆ»å›é ­ï¼ˆé™¤éæ­»è·¯ï¼‰
    if (valid.length > 1) {
        valid = valid.filter(d =>
            !(d.x === -this.lastMove.x && d.y === -this.lastMove.y)
        );
    }

    if (valid.length === 0) return;

    valid.sort((a, b) => {
        const da =
            Math.abs(this.gridX + a.x - target.gridX) +
            Math.abs(this.gridY + a.y - target.gridY);
        const db =
            Math.abs(this.gridX + b.x - target.gridX) +
            Math.abs(this.gridY + b.y - target.gridY);
        return da - db;
    });

    this.dir = valid[0];
    this.lastMove = {...this.dir};
    this.hasDecision = true;
    this.decisionCooldown = 4;
    return;
}


    
    if (!hunterMode) {    
        
// ===== æ¨™æº–AIé‚è¼¯ï¼ˆéHunteræ¨¡å¼æˆ–ç›Ÿå‹ï¼‰=====
        if (Math.abs(this.pixelX - this.gridX*TILE_SIZE) < 2.0 && 
            Math.abs(this.pixelY - this.gridY*TILE_SIZE) < 2.0) {
            
            const dirs = [{x:0,y:-1}, {x:0,y:1}, {x:-1,y:0}, {x:1,y:0}];
            let valid = dirs.filter(d => !isWall(this.gridX + d.x, this.gridY + d.y));
// ğŸ”„ å¡å¾ªç’°å°±å…è¨±å›é ­ä¸€æ¬¡
if (this.loopCounter > 4) {
    valid = dirs.filter(d => !isWall(this.gridX + d.x, this.gridY + d.y));
    this.loopCounter = 0;
}
            
            // é¿å…180åº¦è½‰å½
            if (valid.length > 1) {
                valid = valid.filter(d => !(d.x === -this.lastMove.x && d.y === -this.lastMove.y));
            }
            
            if(valid.length === 0) {
                valid = dirs.filter(d => !isWall(this.gridX + d.x, this.gridY + d.y));
            }
            if(valid.length === 0) return;
            
            // æ¨™æº–AIé‚è¼¯
            if(this.type === 'nic') {
                valid.sort((a, b) => {
                    const distA = Math.abs((this.gridX + a.x) - player.gridX) + Math.abs((this.gridY + a.y) - player.gridY);
                    const distB = Math.abs((this.gridX + b.x) - player.gridX) + Math.abs((this.gridY + b.y) - player.gridY);
                    return distA - distB;
                });
                this.dir = valid[0];
            } else if(this.type === 'laure') {
                const targetX = player.gridX + (player.dir.x * 4);
                const targetY = player.gridY + (player.dir.y * 4);
                valid.sort((a, b) => {
                    const distA = Math.abs((this.gridX + a.x) - targetX) + Math.abs((this.gridY + a.y) - targetY);
                    const distB = Math.abs((this.gridX + b.x) - targetX) + Math.abs((this.gridY + b.y) - targetY);
                    return distA - distB;
                });
                this.dir = valid[0];
            } else if(this.type === 'sehee') {
                if(Math.random() < 0.2) {
                    valid.sort((a, b) => {
                        const distA = Math.abs((this.gridX + a.x) - player.gridX) + Math.abs((this.gridY + a.y) - player.gridY);
                        const distB = Math.abs((this.gridX + b.x) - player.gridX) + Math.abs((this.gridY + b.y) - player.gridY);
                        return distA - distB;
                    });
                    this.dir = valid[0];
                } else {
                    this.dir = valid[Math.floor(Math.random() * valid.length)];
                }
            }
            this.lastMove = { ...this.dir };
        }
    }
}
}
let player;
let enemies = [];
let hunterPlayedOnce = false;   // æ˜¯å¦çµæŸé Hunterï¼ˆè¼¸è´éƒ½ç®—ï¼‰
let infoStage = 0;              // 0=åŸºç¤, 1=é€²éšï¼ˆå·²è§£é–ï¼‰
let hunterInfoViewed = false;

// ======================
// ğŸ’¬ Threat Subtitle UI
// ======================
let threatSubtitle = null;
let threatSubtitleTint = "rgba(0,0,0,0.35)";
// { text, startTime, duration }

function showThreatSubtitle(text, duration = 1800, tint = null) {
    threatSubtitle = {
        text,
        startTime: performance.now(),
        duration
    };

    if (tint) {
        threatSubtitleTint = tint;
    } else {
        threatSubtitleTint = "rgba(0,0,0,0.35)";
    }
}

let laureSubtitleShown = false;
let trapFlashTime = 0;
let unknownThreat = false;

function isWall(x, y) {
    if(x<0 || x>=COLS || y<0 || y>=ROWS) return true;
    return map[y][x] === 1;
}

function findNearestDotDir(entity) {
    let best = null;
    let bestDist = Infinity;

    dots.forEach(k => {
        const [x, y] = k.split(',').map(Number);
        const d = Math.abs(entity.gridX - x) + Math.abs(entity.gridY - y);
        if (d < bestDist) {
            bestDist = d;
            best = {x, y};
        }
    });

    if (!best) return null;

    const dirs = [{x:0,y:-1}, {x:0,y:1}, {x:-1,y:0}, {x:1,y:0}];
    let valid = dirs.filter(d => {
        const nx = entity.gridX + d.x;
        const ny = entity.gridY + d.y;
        return !isWall(nx, ny);
    });

// ğŸ”„ å¡å¾ªç’°å°±å…è¨±å›é ­ä¸€æ¬¡
if (entity.loopCounter > 4) {
    valid = dirs.filter(d =>
        !isWall(entity.gridX + d.x, entity.gridY + d.y)
    );
    entity.loopCounter = 0;
}
    if (valid.length === 0) return null;

    valid.sort((a, b) => {
        const da = Math.abs((entity.gridX+a.x) - best.x) +
                   Math.abs((entity.gridY+a.y) - best.y);
        const db = Math.abs((entity.gridX+b.x) - best.x) +
                   Math.abs((entity.gridY+b.y) - best.y);
        return (da - db) + (entity.personalityBias || 0);
    });

    return valid[0];
}

function updateThreatLevel() {
const livesEl = document.getElementById('hunterLivesUI');
    const threatSpan = document.getElementById('threatLevel');

// ğŸ”„ reset threat style first
// æ¯æ¬¡æ›´æ–°å‰æ¸…æ‰
threatSpan.style.fontSize = "1em";
threatSpan.style.textShadow = "none";
threatSpan.style.letterSpacing = "normal";
threatSpan.style.color = "var(--color-warn-gray)";


if (hunterMode && unknownThreat) {
    threatSpan.innerText = "???";
    threatSpan.style.color = "var(--color-danger-blood)";
threatSpan.style.fontSize = "1.4em";
threatSpan.style.textShadow = `
    0 0 6px rgba(180,40,40,0.6),
    0 0 12px rgba(180,40,40,0.4)
`;
    
    threatSpan.style.fontWeight = "normal";

    const pulse =
        (Math.sin(performance.now() * 0.002) + 1) * 0.5;
    threatSpan.style.opacity = 0.7 + pulse * 0.3;

    // â¤ï¸ é¡¯ç¤ºç”Ÿå‘½
    livesEl.classList.remove('hidden');
    livesEl.innerText = `LIVES: ${hunterLives}`;

    return;
}

livesEl.classList.add('hidden');
    
    if (difficulty === 'HARD') {
        threatSpan.innerText = "CRITICAL";
        threatSpan.style.color = "var(--color-danger-blood)";
threatSpan.style.textShadow = `
    0 0 6px rgba(180,40,40,0.6),
    0 0 12px rgba(180,40,40,0.4)
`;
        threatSpan.style.fontWeight = "normal";
        return;
    }

    const ratio = totalDots > 0 ? (score / totalDots) : 0;
    if (ratio >= 0.5) {
        threatSpan.innerText = "CRITICAL";
        threatSpan.style.color = "var(--color-danger-blood)";
threatSpan.style.textShadow = `
    0 0 6px rgba(180,40,40,0.6),
    0 0 12px rgba(180,40,40,0.4)
`;
        threatSpan.style.fontWeight = "normal";
    } else if (ratio >= 0.33) {
        threatSpan.innerText = "ESCALATING";
        threatSpan.style.color = "var(--color-obsess-orange)";
threatSpan.style.textShadow = `
    0 0 6px rgba(180,40,40,0.6),
    0 0 12px rgba(180,40,40,0.4)
`;
        threatSpan.style.fontWeight = "normal";
    } else {
        threatSpan.innerText = "LOW";
        threatSpan.style.color = "var(--color-warn-gray)";
        threatSpan.style.fontWeight = "normal";
    }
}

function updateInfoUI() {
  // å…ˆå…¨éƒ¨é—œæ‰ï¼ˆæœ€å®‰å…¨ï¼‰
  infoToggle.classList.remove(
    'info-pulse-strong',
    'info-pulse-soft',
    'info-disabled'
  );

  // âŒ Hunter æ²’è§£é– or ä¸åœ¨ Hunter æ¨¡å¼ â†’ ç›´æ¥éš±è—
  if (!hunterUnlocked || !hunterMode) {
    infoToggle.classList.add('hidden');
    return;
  }

  // âœ… Hunter æ¨¡å¼æ‰é¡¯ç¤º
  infoToggle.classList.remove('hidden');

  // éŠæˆ²ä¸­ â†’ ç°æ‰
  if (gameState === 'playing') {
    infoToggle.classList.add('info-disabled');
    return;
  }

  // æ ¹æ“šç­‰ç´šç™¼å…‰
  if (infoStage === 0) {
  infoToggle.classList.add('info-pulse-strong');
} else if (infoStage === 1) {
  infoToggle.classList.add('info-pulse-soft');
}
}

function resetUI() {
    score = 0;
    document.getElementById('score').innerText = '0%';
    



    unknownThreat = false;   // âœ… é—œéµï¼šæ¨¡å¼åˆ‡æ›å°±æ¸…æ‰ ???

    updateThreatLevel();

const msgEl = document.getElementById('deathMsg');
const titleEl = document.getElementById('gameOverTitle');

msgEl.style.color = "";
msgEl.style.borderLeftColor = "";
msgEl.style.textShadow = "";

titleEl.style.color = "";

    document.getElementById('startScreen').classList.remove('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    document.getElementById('winScreen').classList.add('hidden');
    document.getElementById('mercyScreen').classList.add('hidden');
    document.getElementById('mainHeader').classList.remove('header-locked');
    
    if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
    gameState = 'ready';
    keys = {};
updateInfoUI();

}

function initGame() {
    if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
    const size = document.getElementById('gameArea').clientWidth;
    canvas.width = size; canvas.height = size;
    TILE_SIZE = size / COLS;
    
    document.getElementById('mainHeader').classList.remove('header-locked');
    
    map = MAPS[currentMapIdx]; 
    dots.clear();
    for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) if(map[y][x] === 0) dots.add(`${x},${y}`);
    totalDots = dots.size;
    
    player = new Entity(1, 1, COLORS.dawn, 'player');
    enemies = [
        new Entity(COLS-2, 1, COLORS.nic, 'nic'),
        new Entity(1, ROWS-2, COLORS.laure, 'laure'),
        new Entity(COLS-2, ROWS-2, COLORS.sehee, 'sehee')
    ];

// === Ensure enemies start as NORMAL ===
enemies.forEach(e => {
    e.isEnhanced = false;
});

enemies.forEach(e => {
    e.spawnScatterTimer = 40; // ç´„å‰ 40 æ¬¡ think å¼·åˆ¶åˆ†æ•£
});

enemies.forEach(e => {
    e.personalityBias = Math.random() * 2 - 1; // å¼·ä¸€é»
});

    hunterAllies = [];
    
    score = 0;
    mercyUsed = false; 
    

    // === Reset Hunter Lives ===
    if (hunterMode) {
        hunterLives = 3;

        hunterHitCooldown = 0;
    }
    document.getElementById('score').innerText = '0%';
    updateThreatLevel();
    gameState = 'playing';
updateInfoUI();
// ğŸ§¹ Reset Hunter environmental effects
corrosionTiles.clear();
activeTrap = null;
unknownThreat = false;   // âœ… é‡ç½® ??? ç‹€æ…‹

    // === Hunter Survival Time Init ===
    if (hunterMode) {
        hunterStartTime = Date.now();
        hunterSurviveTime = 0;
    }
    keys = {};
    gameLoop();
}

function triggerMercy(enemy) {
    gameState = 'paused';
    const msgEl = document.getElementById('mercyMsg');
    const quotes = QUOTES_MERCY[enemy.type];
    
    const nameMap = { 'nic': 'NICOLETTE', 'sehee': 'SEHEE', 'laure': 'LAURE' };
    const displayName = nameMap[enemy.type] || enemy.type.toUpperCase();
    
    msgEl.innerText = `${displayName}: ${quotes[Math.floor(Math.random() * quotes.length)]}`;
    
    document.getElementById('mainHeader').classList.add('header-locked');
    document.getElementById('mercyScreen').classList.remove('hidden');
    mercyUsed = true;
    
    player.gridX = 1; player.gridY = 1;
    player.pixelX = TILE_SIZE; player.pixelY = TILE_SIZE;
    player.dir = {x:0, y:0}; player.nextDir = {x:0, y:0};
    keys = {};
}

function gameLoop(currentTime) {


    if(gameState !== 'playing') {
       if(animationId) { cancelAnimationFrame(animationId); animationId = null; }
       return;
    }
// ===== FPS LOCK (120pfps) =====
if (!gameLoop.lastTime) gameLoop.lastTime = currentTime;

const delta = currentTime - gameLoop.lastTime;

if (delta < 8.33) {  // 1000 / 120
    animationId = requestAnimationFrame(gameLoop);
    return;
}

gameLoop.lastTime = currentTime;
    // === Update Hunter Survival Time ===
    if (hunterMode) {
        hunterSurviveTime = Date.now() - hunterStartTime;
    }
if (hunterMode && hunterHitCooldown > 0) {
    hunterHitCooldown--;
}
    
    
if(player) {
        if(player.gridX < 0 || player.gridX >= COLS || 
           player.gridY < 0 || player.gridY >= ROWS) {
            player.gridX = Math.max(1, Math.min(COLS-2, player.gridX));
            player.gridY = Math.max(1, Math.min(ROWS-2, player.gridY));
            player.pixelX = player.gridX * TILE_SIZE;
            player.pixelY = player.gridY * TILE_SIZE;
            player.dir = {x:0, y:0};
            player.nextDir = {x:0, y:0};
        }
        
        if(isWall(player.gridX, player.gridY)) {
            for(let radius = 1; radius <= 3; radius++) {
                for(let dx = -radius; dx <= radius; dx++) {
                    for(let dy = -radius; dy <= radius; dy++) {
                        const testX = player.gridX + dx;
                        const testY = player.gridY + dy;
                        if(!isWall(testX, testY)) {
                            player.gridX = testX;
                            player.gridY = testY;
                            player.pixelX = player.gridX * TILE_SIZE;
                            player.pixelY = player.gridY * TILE_SIZE;
                            return;
                        }
                    }
                }
            }
        }
    }

    ctx.fillStyle = COLORS.wall; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);
if (trapFlashTime > 0) {
    ctx.fillStyle = "rgba(180,30,30,0.25)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    trapFlashTime--;
}
    
    for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) {
        if(map[y][x] === 1) { 
            ctx.strokeStyle = COLORS.wallBorder; 
            ctx.lineWidth = 1; 
            ctx.strokeRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE); 
        } else if(dots.has(`${x},${y}`)) { 
            ctx.fillStyle = COLORS.dot; 
            ctx.fillRect(x*TILE_SIZE + TILE_SIZE/2 -2, y*TILE_SIZE + TILE_SIZE/2 -2, 4, 4); 
        }
    }
// ===============================
// ğŸ’¬ THREAT SUBTITLE (MAP WALL)
// ===============================
if (threatSubtitle) {
    const now = performance.now();
    const elapsed = now - threatSubtitle.startTime;

    if (elapsed > threatSubtitle.duration) {
        threatSubtitle = null;
    } else {
        const fade =
            elapsed < 200
                ? elapsed / 200
                : elapsed > threatSubtitle.duration - 300
                    ? (threatSubtitle.duration - elapsed) / 300
                    : 1;

        const y =
            (ROWS - 1) * TILE_SIZE + TILE_SIZE / 2;

        ctx.save();
        ctx.globalAlpha = 0.75 * fade;

        ctx.fillStyle = threatSubtitleTint;
        ctx.fillRect(
            0,
            y - TILE_SIZE * 0.45,
            canvas.width,
            TILE_SIZE * 0.9
        );

        ctx.fillStyle = "#cfcfcf";
        ctx.font = `${TILE_SIZE * 0.6}px Share Tech Mono`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.fillText(
            threatSubtitle.text,
            canvas.width / 2,
            y
        );

        ctx.restore();
    }
}

// ======================
// ğŸŸ£ DRAW CORROSION TILES
// ======================
const now = Date.now();

corrosionTiles.forEach((data, key) => {
    if (now > data.expireTime) {
        corrosionTiles.delete(key);
        return;
    }

    const [x, y] = key.split(',').map(Number);
    const remain = (data.expireTime - now) / 2500;

    ctx.fillStyle = `rgba(140, 60, 180, ${0.25 + remain * 0.25})`;
    ctx.fillRect(
        x * TILE_SIZE + 2,
        y * TILE_SIZE + 2,
        TILE_SIZE - 4,
        TILE_SIZE - 4
    );
});

// ======================
// ğŸ”´ DRAW TRAP
// ======================
if (activeTrap) {
    const remaining =
        Math.max(0, Math.ceil((activeTrap.expireTime - Date.now()) / 1000));

    ctx.fillStyle = "rgba(180,30,30,0.6)";
    ctx.fillRect(
        activeTrap.x * TILE_SIZE + 4,
        activeTrap.y * TILE_SIZE + 4,
        TILE_SIZE - 8,
        TILE_SIZE - 8
    );

    ctx.fillStyle = "#fff";
    ctx.font = `${TILE_SIZE / 2}px monospace`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(
        remaining,
        activeTrap.x * TILE_SIZE + TILE_SIZE / 2,
        activeTrap.y * TILE_SIZE + TILE_SIZE / 2
    );
}
    
    player.update(); 
    player.draw();

// ======================
// ğŸ”´ TRAP CHECK
// ======================
if (hunterMode && activeTrap) {

    // ç©å®¶è¸©åˆ°é™·é˜± â†’ å®‰å…¨è§£é™¤
    if (
        player.gridX === activeTrap.x &&
        player.gridY === activeTrap.y
    ) {
        activeTrap = null;
    }

    // å€’æ•¸çµæŸä½†æ²’è¸© â†’ æ‰£å‘½
    else if (Date.now() > activeTrap.expireTime) {
    hunterLives--;
updateThreatLevel();

    trapFlashTime = 15; // ğŸ”¥ ç•«é¢ç´…é–ƒ 15 å¹€

    showThreatSubtitle(
  randomFrom(ENHANCED_THREATS_SEHEE_BOOM),
  1600,
  "rgba(160,40,40,0.45)"
);

    activeTrap = null;

    if (hunterLives <= 0) {
        endGame(false, "TRAPPED", "late");
        return;
    }
}
}
    
    enemies.forEach(e => {
        e.think();
        e.update();
        e.draw();


        // === HUNTER MODE: only NORMAL enemies eat dots ===
if (hunterMode && !e.isEnhanced) {
    const k = `${e.gridX},${e.gridY}`;
    if (dots.has(k)) {
        dots.delete(k);
        const eaten = totalDots - dots.size;
        document.getElementById('score').innerText =
            Math.floor((eaten / totalDots) * 100) + '%';
    }
}
// ğŸŸ¡ Corruption Level (dot-based)
if (hunterMode) {
    const ratio = totalDots > 0
        ? (totalDots - dots.size) / totalDots
        : 0;

    let newLevel = 0;
    if (ratio >= 0.9) newLevel = 3;
    else if (ratio >= 0.75) newLevel = 2;
    else if (ratio >= 0.5) newLevel = 1;

    corruptionLevel = newLevel;
}

        const dist = Math.hypot(player.pixelX - e.pixelX, player.pixelY - e.pixelY);

        if (dist < TILE_SIZE / 1.5) {
// â˜ ï¸ Nicolette Execute = instant death
if (
    hunterMode &&
    e.type === 'nic' &&
    e.isEnhanced &&
    e.isExecuteMode
) {
    endGame(false, "EXECUTED", "extreme");
    return;
}

// === HUNTER MODE: Player gets hit by ENHANCED enemy ONLY ===
if (hunterMode && e.isEnhanced && hunterHitCooldown <= 0) {
    hunterLives--;
canvas.style.filter = 'brightness(0.85)';
setTimeout(() => {
    canvas.style.filter = 'none';
}, 150);
updateThreatLevel();
    hunterHitCooldown = 180; // ç´„3 ç§’
player.hurtFlashTime =performance.now();
console.log(`ğŸ’¥ Hit by ENHANCED ${e.type}! Lives left: ${hunterLives}`);

    if (hunterLives <= 0) {
        endGame(false, "HUNTED DOWN", "late");
        return;
    }

    return; // åƒåˆ°å‚·å®³å¾Œï¼Œä¸å†åŸ·è¡Œå…¶ä»–åˆ¤å®š
}
           // ğŸ¹ HUNTER MODE: Mark NORMAL enemies only
if (hunterMode && !e.isAlly && !e.isEnhanced && !e.isMarked) {
    e.isMarked = true;
    e.markTime = Date.now();
    console.log(`ğŸ¯ æ¨™è¨˜æ™®é€šæ•µäºº ${e.type}`);
    return;
}

            // ===== åŸæœ¬æ­»äº¡ / mercy é‚è¼¯ï¼ˆéHunteræ¨¡å¼ï¼‰=====
            if (!hunterMode) {  // åªåœ¨éHunteræ¨¡å¼åŸ·è¡Œ
                if (difficulty === 'EASY' && !mercyUsed) {
                    triggerMercy(e);
                    return;
                }

                const ratio = score / totalDots;
                let quotesList, styleType;

                if (difficulty === 'HARD') {
                    quotesList = QUOTES_EXTREME[e.type];
                    styleType = 'extreme';
                } else if (ratio >= 0.5) {
                    quotesList = QUOTES_LATE[e.type];
                    styleType = 'late';
                } else if (ratio >= 0.33) {
                    quotesList = QUOTES_MID[e.type];
                    styleType = 'mid';
                } else {
                    quotesList = QUOTES_EARLY[e.type];
                    styleType = 'early';
                }

                const randomQuote = quotesList[Math.floor(Math.random() * quotesList.length)];
                const name = e.type === 'nic' ? 'NICOLETTE' : e.type === 'sehee' ? 'SEHEE' : 'LAURE';

                endGame(false, `${name}: ${randomQuote}`, styleType);
            }
        }
    });

// ===== HUNTER MODE: update & draw allies =====
if (hunterMode) {
    hunterAllies.forEach(a => {
        a.think();
        a.update();
        a.draw();
// ğŸ¤ Ally marks NORMAL enemies only
enemies.forEach(e => {
    const dist = Math.hypot(a.pixelX - e.pixelX, a.pixelY - e.pixelY);
    if (
        dist < TILE_SIZE / 1.5 &&
        !e.isMarked &&
        !e.isEnhanced &&
        !e.isAlly
    ) {
        e.isMarked = true;
        e.markTime = Date.now();
        console.log(`ğŸ¤ Ally marked normal enemy ${e.type}`);
    }
});
    });
}

// ===== HUNTER MODE: Ally rebellion (5s) =====
if (hunterMode && hunterAllies.length > 0) {
    const now = Date.now();

    for (let i = hunterAllies.length - 1; i >= 0; i--) {
        const a = hunterAllies[i];

        if (now - a.allyStartTime >= 3000) {
            // ğŸ’” Ally turns ENHANCED enemy
            a.isAlly = false;
            a.isEnhanced = true;
if (!unknownThreat) {
    unknownThreat = true;
    updateThreatLevel(); // ğŸ”¥ å¼·åˆ¶åˆ·æ–° UI
}
            a.color = ENTITY_COLORS.enhanced[a.type] || "#ff0000";
            a.speedMultiplier = 1.0;

            // ç§»å‡ºç›Ÿå‹
            hunterAllies.splice(i, 1);

            // åŠ å›æ•µäººåˆ—è¡¨
            enemies.push(a);

            console.log(`âš ï¸ Ally ${a.type} rebelled â†’ ENHANCED`);
        }
    }
}

    if (hunterMode) {
        const now = Date.now();
        const newlyConverted = enemies.filter(e => 
            e.isMarked && !e.isAlly && now - e.markTime > 500
        );

        if (newlyConverted.length > 0) {
            newlyConverted.forEach(e => {
    e.isMarked = false;
    e.isAlly = true;
    e.isEnhanced = false;

e.allyStartTime = Date.now();

    e.color = ENTITY_COLORS.ally;
e.speedMultiplier = 1.0; // æ¢å¾©åŸé€Ÿ

    // ğŸ¤ ç›Ÿå‹è®Šæ…¢
    e.speedMultiplier = 0.5;

    hunterAllies.push(e);
});

            enemies = enemies.filter(e => !e.isAlly);

            if (enemies.length === 0) {
                endGame(true);
            }
        }

        if (dots.size === 0 && enemies.length > 0) {
            endGame(false, "ALL DOTS CONSUMED", "late");
        }
    }

    animationId = requestAnimationFrame(gameLoop);
}

function isIntersection(x, y) {
    let count = 0;
    if (!isWall(x+1,y)) count++;
    if (!isWall(x-1,y)) count++;
    if (!isWall(x,y+1)) count++;
    if (!isWall(x,y-1)) count++;
    return count >= 3;
}

function endGame(win, msg, styleType) {
    gameState = win ? 'win' : 'gameover';
// âœ… åªè¦ Hunter æ¨¡å¼çµæŸï¼ˆä¸ç®¡è¼¸è´ï¼‰ï¼Œå°±ç®—é«”é©—é
if (difficulty === 'HUNTER') {
    hunterPlayedOnce = true;
infoStage = 1;
infoSeen = false; // ğŸ”¥ å¼·åˆ¶é‡æ–°æç¤º
  triggerInfoAlert();
}
    if(animationId) { cancelAnimationFrame(animationId); animationId = null; }
    if(win) {
       if (!hunterUnlocked && 
   (difficulty === 'EASY' || difficulty === 'NORMAL' || difficulty === 'HARD')) {
    hunterUnlocked = true;
    showHunterToast();
}
        
        let victory;
        if (difficulty === 'EASY') {
            victory = VICTORY_TEXTS.easy;
        } else if (difficulty === 'HARD') {
            victory = VICTORY_TEXTS.hard;
        } else if (difficulty === 'HUNTER') {
            victory = VICTORY_TEXTS.hunter; // æ–°å¢ Hunter Mode å‹åˆ©
        } else {
            victory = VICTORY_TEXTS.normal;
        }
        
        
        
        const winScreen = document.getElementById('winScreen');
        const titleEl = winScreen.querySelector('h2');
        const contentEl = winScreen.querySelector('div');
        
        titleEl.textContent = victory.title;
        titleEl.style.color = victory.color;
        
        contentEl.innerHTML = `
            > STATUS: ${victory.status}<br>
            > THOUGHT: ${victory.thought}<br>
            <br>
            <span style="color:${victory.color}; font-style:italic;">${victory.quote}</span>
        `;
        
        winScreen.classList.remove('hidden');
        
    } else {
        const msgEl = document.getElementById('deathMsg');
        const titleEl = document.getElementById('gameOverTitle');
// ============================
// ğŸ§¨ HUNTER MODE â€“ GLITCH DEATH
// ============================
if (hunterMode) {
    const screen = document.getElementById('gameOverScreen');

    let glitchTimer = setInterval(() => {
        const dx = (Math.random() - 0.5) * 4;
        const dy = (Math.random() - 0.5) * 4;

        screen.style.transform = `translate(${dx}px, ${dy}px)`;
        screen.style.textShadow = `
            2px 0 rgba(255,0,0,0.6),
           -2px 0 rgba(0,255,255,0.6)
        `;
    }, 50);

    setTimeout(() => {
        clearInterval(glitchTimer);
        screen.style.transform = 'none';
        screen.style.textShadow = 'none';
    }, 1200);
}
        if (hunterMode) {
    const seconds = (hunterSurviveTime / 1000).toFixed(1);
    msgEl.innerText = `YOU SURVIVED ${seconds}s\n\n${msg || ''}`;

    // ğŸ”¥ Hunter death visual
    msgEl.style.color = "var(--color-danger-blood)";
    msgEl.style.borderLeftColor = "var(--color-danger-blood)";
    msgEl.style.textShadow =
        "0 0 6px rgba(255,40,40,0.6), 0 0 12px rgba(255,0,0,0.4)";

    titleEl.innerText = "// HUNT FAILED";
    titleEl.style.color = "var(--color-danger-blood)";
} else {
    msgEl.innerText = msg;
}
        
        msgEl.style.textShadow = "none";
        titleEl.style.textShadow = "none";
        
        if (styleType === 'extreme') {
          msgEl.style.color = "#cc2222"; 
          msgEl.style.borderLeftColor = "#cc2222"; 
          titleEl.innerText = "// FINALITY REACHED"; 
          titleEl.style.color = "#cc2222";
        } else if (styleType === 'late') {
          msgEl.style.color = "var(--color-danger-blood)"; 
          msgEl.style.borderLeftColor = "var(--color-danger-blood)"; 
          titleEl.innerText = "// OWNERSHIP ESTABLISHED"; 
          titleEl.style.color = "var(--color-danger-blood)";
        } else if (styleType === 'mid') {
          msgEl.style.color = "var(--color-obsess-orange)"; 
          msgEl.style.borderLeftColor = "var(--color-obsess-orange)"; 
          titleEl.innerText = "// TARGET LOCKED"; 
          titleEl.style.color = "var(--color-obsess-orange)";
        } else {
          msgEl.style.color = "var(--color-warn-gray)"; 
          msgEl.style.borderLeftColor = "var(--color-warn-gray)"; 
          titleEl.innerText = "// TARGET SECURED"; 
          titleEl.style.color = "#555";
        }
        document.getElementById('gameOverScreen').classList.remove('hidden');
gameOverScreen.classList.add('hunter-death');
    }
updateInfoUI();
}

document.getElementById('mapToggle').addEventListener('click', () => {
    currentMapIdx = (currentMapIdx + 1) % 3;
    document.getElementById('mapToggle').innerText = `[MAP: 0${currentMapIdx + 1}]`;
    document.getElementById('mapText').innerText = `[MAP: ${mapNames[currentMapIdx]}]`;
    resetUI(); 
});

infoToggle.addEventListener('click', () => {
  if (gameState === 'playing') return;

// â­ é¡¯ç¤ºç”¨çš„ stageï¼ˆä¸ä¸€å®šç­‰æ–¼ infoStageï¼‰
  let displayStage = infoStage;

  // âœ… åªè¦å®Œæˆé Hunterï¼Œå°±ç›´æ¥é¡¯ç¤ºå®Œæ•´ç‰ˆ
  if (hunterPlayedOnce && infoStage >= 1) {
    displayStage = 2;
  }

  

  infoContent.innerText = INFO_TEXT[displayStage];
  infoOverlay.classList.remove('hidden');
});

const closeInfo = () => {
  infoOverlay.classList.add('hidden');

  // âœ… å·²ç¶“å®Œæˆé Hunterï¼Œä¸”ç›®å‰æ˜¯é€²éšéšæ®µ
  if (hunterPlayedOnce && infoStage === 1) {
    infoStage = 2;
  }

  updateInfoUI();
};

infoCloseBtn.addEventListener('click', closeInfo);
infoCloseBtn.addEventListener('pointerup', closeInfo);

document.getElementById('diffToggle').addEventListener('click', () => {
    const toggleEl = document.getElementById('diffToggle');
    const modeTextEl = document.getElementById('modeText');
    const warnTextEl = document.getElementById('warnText');

    if (difficulty === 'NORMAL') {
        difficulty = 'EASY';
        hunterMode = false;
        toggleEl.innerText = "[MODE: EASY]";
        toggleEl.style.color = "var(--color-safe-green)";
        modeTextEl.innerText = "[CURRENT: MERCY PROTOCOL ACTIVE]";
        modeTextEl.style.color = "var(--color-safe-green)";
        warnTextEl.innerText = "RUN DAWN RUN.";
    } else if (difficulty === 'EASY') {
        difficulty = 'HARD';
        hunterMode = false;
        toggleEl.innerText = "[MODE: HARD]";
        toggleEl.style.color = "var(--color-danger-blood)";
        modeTextEl.innerText = "[CURRENT: DEATHWISH PROTOCOL]";
        modeTextEl.style.color = "var(--color-danger-blood)";
        warnTextEl.innerText = "ESCAPE IS IMPOSSIBLE.(NSFW)";
    } else if (difficulty === 'HARD' && hunterUnlocked) {
        difficulty = 'HUNTER';
        hunterMode = true;
        toggleEl.innerText = "[MODE: HUNTER]";
        toggleEl.style.color = "#d6b36a";
        modeTextEl.innerText = "[CURRENT: HUNTER PROTOCOL]";
        modeTextEl.style.color = "#d6b36a";
        warnTextEl.innerText = "YOU ARE THE PREDATOR.";
    } else {
        difficulty = 'NORMAL';
        hunterMode = false;
        toggleEl.innerText = "[MODE: NORMAL]";
        toggleEl.style.color = "var(--color-warn-gray)";
        modeTextEl.innerText = "[CURRENT: STANDARD PROTOCOL]";
        modeTextEl.style.color = "#aaa";
        warnTextEl.innerText = "DO NOT LET THEM CATCH YOU.";
    }

    resetUI();
});

window.addEventListener('keydown', e => { 
    if(gameState !== 'playing') return; 
    
    const validKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 
                      'w', 'a', 's', 'd', 'W', 'A', 'S', 'D'];
    
    if(validKeys.includes(e.key)) {
        e.preventDefault();
        keys[e.key] = true;
        
        switch(e.key.toLowerCase()) {
            case 'arrowup':
            case 'w':
                player.nextDir = {x:0, y:-1};
                break;
            case 'arrowdown':
            case 's':
                player.nextDir = {x:0, y:1};
                break;
            case 'arrowleft':
            case 'a':
                player.nextDir = {x:-1, y:0};
                break;
            case 'arrowright':
            case 'd':
                player.nextDir = {x:1, y:0};
                break;
        }
    }
}, {passive: false});

window.addEventListener('keyup', e => {
    const validKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 
                      'w', 'a', 's', 'd', 'W', 'A', 'S', 'D'];
    if(validKeys.includes(e.key)) {
        keys[e.key] = false;
    }
});

let touchStartX = 0, touchStartY = 0;
const MIN_SWIPE_DISTANCE = 15;

gameArea.addEventListener('touchstart', e => { 
    e.preventDefault();
    if(gameState !== 'playing') return;
    
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
}, {passive: false});

gameArea.addEventListener('touchmove', e => { 
    e.preventDefault();
    if(gameState !== 'playing') return;
    
    const touchX = e.touches[0].clientX;
    const touchY = e.touches[0].clientY;
    
    const deltaX = touchX - touchStartX;
    const deltaY = touchY - touchStartY;
    
    if(Math.abs(deltaX) < MIN_SWIPE_DISTANCE && Math.abs(deltaY) < MIN_SWIPE_DISTANCE) {
        return;
    }
    
    if(Math.abs(deltaX) > Math.abs(deltaY)) {
        if(deltaX > 0) {
            player.nextDir = {x:1, y:0};
        } else {
            player.nextDir = {x:-1, y:0};
        }
    } else {
        if(deltaY > 0) {
            player.nextDir = {x:0, y:1};
        } else {
            player.nextDir = {x:0, y:-1};
        }
    }
    
    touchStartX = touchX;
    touchStartY = touchY;
}, {passive: false});

function bindBtn(id, action) { 
    const btn = document.getElementById(id); 
    if(!btn) return; 
    const handler = (e) => { 
        e.preventDefault(); 
        e.stopPropagation(); 
        action(); 
    }; 
    btn.addEventListener('touchstart', handler, {passive: false}); 
    btn.addEventListener('click', handler); 
    btn.addEventListener('pointerup', handler); 
}

bindBtn('startBtn', () => { 
    document.getElementById('startScreen').classList.add('hidden'); 
    initGame(); 
});



bindBtn('retryBtn', () => { 
    document.getElementById('gameOverScreen').classList.add('hidden'); 
    initGame(); 
});
bindBtn('nextBtn', () => { 
    document.getElementById('winScreen').classList.add('hidden'); 
    initGame(); 
});
bindBtn('escapeBtn', () => { 
    document.getElementById('mercyScreen').classList.add('hidden'); 
    document.getElementById('mainHeader').classList.remove('header-locked');
    if(animationId) { cancelAnimationFrame(animationId); animationId = null; }
    gameState = 'playing'; 
    gameLoop(); 
});
function lerpColor(a, b, t) {
    const ar = parseInt(a.slice(1,3), 16);
    const ag = parseInt(a.slice(3,5), 16);
    const ab = parseInt(a.slice(5,7), 16);

    const br = parseInt(b.slice(1,3), 16);
    const bg = parseInt(b.slice(3,5), 16);
    const bb = parseInt(b.slice(5,7), 16);

    const r = Math.round(ar + (br - ar) * t);
    const g = Math.round(ag + (bg - ag) * t);
    const b2 = Math.round(ab + (bb - ab) * t);

    return `rgb(${r},${g},${b2})`;
}
function mixColor(c1, c2, t) {
    const a = hexToRgb(c1);
    const b = hexToRgb(c2);
    const mix = (x, y) => Math.round(x + (y - x) * t);
    return `rgb(${mix(a.r,b.r)}, ${mix(a.g,b.g)}, ${mix(a.b,b.b)})`;
}

function hexToRgb(hex) {
    hex = hex.replace('#', '');
    return {
        r: parseInt(hex.substring(0,2), 16),
        g: parseInt(hex.substring(2,4), 16),
        b: parseInt(hex.substring(4,6), 16)
    };
}

function triggerInfoAlert() {
  infoToggle.classList.add('info-alert');

  setTimeout(() => {
    infoToggle.classList.remove('info-alert');
  }, 6000);
}

// ===============================
// ğŸ”“ HUNTER UNLOCK â€” SYS.LOG
// ===============================
let sysLogClicks = 0;

const sysLogEl = document.getElementById('sysLog');

if (sysLogEl) {
    sysLogEl.addEventListener('click', () => {
        if (hunterUnlocked) return;

        sysLogClicks++;
        console.log('SYS.LOG clicks:', sysLogClicks);

        if (sysLogClicks >= 5 && !hunterUnlocked) {
    hunterUnlocked = true;

    sysLogEl.textContent = 'DW.ERR';
    sysLogEl.style.color = '#d6b36a';

    showHunterToast();
}
    });
}

function showHunterToast(text = '[ HUNTER PROTOCOL ] UNLOCKED') {
    if (hunterToastShown) return;
    hunterToastShown = true;

    const toast = document.getElementById('hunterToast');
    if (!toast) return;

    toast.textContent = text;
    toast.classList.remove('hidden');

    // å¼·åˆ¶ reflow
    toast.offsetHeight;

    toast.classList.add('show');

    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            toast.classList.add('hidden');
        }, 400);
    }, 1800);
}
updateInfoUI();
</script>
</body>
</html>
